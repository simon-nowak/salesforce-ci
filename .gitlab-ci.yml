image: node:latest


# Cache node modules between jobs
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .sfdx/


stages:
 - deploy-scratch
 - test-scratch
 - delete-scratch
 - deploy-sandbox
 - test-sandbox
 - deploy-production


deploy-scratch-org:
  stage: deploy-scratch
  #only:
    #variables:
      #- $CI_COMMIT_REF_NAME == 'master'
      #- $DEPLOY_SCRATCH_ON_EVERY_COMMIT == 'true'
  except:
    variables:
      - $SCRATCH_DISABLED
  allow_failure: false
  script:
    - install_salesforce_cli
    - authenticate $DEVHUB_AUTH_URL DEVHUB
    - if ! check_daily_scratch_orgs DEVHUB; then exit 1; fi
    - create_scratch_org DEVHUB
    - push_to_scratch_org_and_test
    - echo "$scratch_org_username" > SCRATCH_ORG_USERNAME.txt
    - populate_url_artifact "$scratch_org_username"
    - echo "$environment_html" > ENVIRONMENT.html
  environment:
    name: scratch/$CI_COMMIT_REF_SLUG
    url: $CI_PROJECT_URL/-/jobs/artifacts/master/raw/ENVIRONMENT.html?job=$CI_JOB_NAME
  artifacts:
    paths:
      - SCRATCH_ORG_USERNAME.txt
      - ENVIRONMENT.html
      - ~/.sfdx


test-scratch-lwc:
  stage: test-scratch
  #only:
    #variables:
      #- $CI_COMMIT_REF_NAME == 'master'
      #- $DEPLOY_SCRATCH_ON_EVERY_COMMIT == 'true'
  except:
    variables:
      - $SCRATCH_DISABLED
      - $TEST_DISABLED
  allow_failure: false
  dependencies:
    - deploy-scratch-org
  script:
    - install_jq
    - install_lwc_jest
    - npm run test:unit


test-scratch-apex:
  stage: test-scratch
  only:
    variables:
      - $CI_COMMIT_REF_NAME == 'master'
      - $DEPLOY_SCRATCH_ON_EVERY_COMMIT == 'true'
  except:
    variables:
      - $SCRATCH_DISABLED
      - $TEST_DISABLED
  allow_failure: false
  dependencies:
    - deploy-scratch-org
  script:
    - install_salesforce_cli
    - scratch_org_username=$(cat SCRATCH_ORG_USERNAME.txt)
    - test_apex $scratch_org_username


delete-scratch-org:
  stage: delete-scratch
  only:
    variables:
      - $CI_COMMIT_REF_NAME == 'master'
      - $DEPLOY_SCRATCH_ON_EVERY_COMMIT == 'true'
  except:
    variables:
      - $SCRATCH_DISABLED
  when: manual
  allow_failure: false
  dependencies:
    - deploy-scratch-org
  script:
    - install_salesforce_cli
    - scratch_org_username=$(cat SCRATCH_ORG_USERNAME.txt)
    - delete_scratch_org $scratch_org_username


# TODO: test this with tags instead of a branch

deploy-to-sandbox:
  stage: deploy-sandbox
  only:
    variables:
      - $CI_COMMIT_REF_NAME == 'master'
  except:
    variables:
      - $SANDBOX_DISABLED
  environment:
    name: sandbox
    url: $CI_PROJECT_URL/-/jobs/artifacts/master/raw/ENVIRONMENT.html?job=$CI_JOB_NAME
  script:
    - install_salesforce_cli
    - authenticate $DEVHUB_AUTH_URL DEVHUB
    - get_package_name_and_id DEVHUB
    - build_package_version DEVHUB
    - authenticate $SANDBOX_AUTH_URL SANDBOX
    - install_package_version SANDBOX
    - populate_url_artifact SANDBOX
    - echo "$environment_html" > ENVIRONMENT.html
  artifacts:
    paths:
      - ENVIRONMENT.html


deploy-to-production:
  stage: deploy-production
  only:
    variables:
      - $CI_COMMIT_REF_NAME == 'master'
  except:
    variables:
      - $PRODUCTION_DISABLED
  when: manual
  allow_failure: false
  environment:
    name: production
    url: $CI_PROJECT_URL/-/jobs/artifacts/master/raw/ENVIRONMENT.html?job=$CI_JOB_NAME
  script:
    - install_salesforce_cli
    - authenticate $DEVHUB_AUTH_URL DEVHUB
    - get_package_name_and_id DEVHUB
    - build_package_version DEVHUB
    - authenticate $PRODUCTION_AUTH_URL PRODUCTION
    - promote_package_version PRODUCTION
    - install_package_version PRODUCTION
    - populate_url_artifact PRODUCTION
    - echo "$environment_html" > ENVIRONMENT.html
  artifacts:
    paths:
      - ENVIRONMENT.html


.sfdx_helpers: &sfdx_helpers |

  # Always call install_salesforce_cli first

  function install_salesforce_cli() {

    # Salesforce CLI Environment Variables
    # https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_env_variables.htm

    # By default, the CLI periodically checks for and installs updates.
    # Disable (false) this auto-update check to improve performance of CLI commands.
    export SFDX_AUTOUPDATE_DISABLE=false

    # Set to true if you want to use the generic UNIX keychain instead of the Linux libsecret library or macOS keychain.
    # Specify this variable when using the CLI with ssh or "headless" in a CI environment.
    export SFDX_USE_GENERIC_UNIX_KEYCHAIN=true

    # Specifies the time, in seconds, that the CLI waits for the Lightning Experience custom domain to resolve and become available in a newly-created scratch org.
    # If you get errors about My Domain not configured when you try to use a newly-created scratch org, increase this wait time.
    export SFDX_DOMAIN_RETRY=300

    # For force:package:create, disables automatic updates to the sfdx-project.json file.
    export SFDX_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_CREATE=true

    # For force:package:version:create, disables automatic updates to the sfdx-project.json file.
    export SFDX_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_VERSION_CREATE=true

    # Install Salesforce CLI
    mkdir sfdx
    CLIURL=https://developer.salesforce.com/media/salesforce-cli/sfdx-linux-amd64.tar.xz
    wget -qO- $CLIURL | tar xJ -C sfdx --strip-components 1
    "./sfdx/install"
    export PATH=./sfdx/$(pwd):$PATH

    # Output CLI version and plug-in information
    sfdx update
    sfdx --version
    sfdx plugins --core

  }


  # Install jq json parsing library

  function install_jq() {
    apt update && apt -y install jq
  }


  # Install LWC Jest dependencies

  function install_lwc_jest() {

    if [ ! -f "package.json" ]; then
      npm init -y
    fi

    local scriptValue=$(jq -r '.scripts["test:unit"]' < package.json)

    if [ -n "$scriptValue" ]; then
      local tmp=$(mktemp)
      jq '.scripts["test:unit"]="lwc-jest"' package.json > $tmp
      mv $tmp package.json
    fi

    npm install
    npm install @salesforce/lwc-jest --save-dev

  }


  # Authenticate to Salesforce
  # First argument is the URL itself, second argument is the alias to be used

  function authenticate() {
    local file=$(mktemp)
    echo $1 > $file
    sfdx force:auth:sfdxurl:store --json --sfdxurlfile $file --setalias $2
    rm $file
  }


  # Function to get package name and ID
  # Pass in the dev hub username/alias

  function get_package_name_and_id() {
    package_name=$PACKAGE_NAME
    if [ ! $package_name ]; then
      package_name=$(cat sfdx-project.json | jq -r '.packageDirectories[] | select(.default==true) | .package')
    fi
    if [ ! $package_name ]; then
      package_name=$(cat sfdx-project.json | jq -r '.packageDirectories | .[0] | .package')
    fi
    package_id=$(sfdx force:package:list targetdevhubusername $1 --json | jq -r '.result[] | select(.Name==env.package_name) | .Id')
  }


  # Function to check whether there are daily scratch orgs left -- pass targetusername as argument

  function check_daily_scratch_orgs() {
    local limits=`sfdx force:limits:api:display -u $1 --json`
    local dso=`jq '.result[] | select(.name == "DailyScratchOrgs")' <<< $limits`
    local dsomax=`jq '.max' <<< $dso`
    local dsorem=`jq '.remaining' <<< $dso`
    if [ $dsorem -le 0 ]; then
      echo "ERROR: Limit of $dsomax Daily Scratch Orgs reached"
    else
      echo "$dsorem of $dsomax Daily Scratch Orgs previously created - OK to proceed"
    fi
    return $(( $dsorem <= 0 ))
  }


  # Function to build a package version
  # Pass in the dev hub username/alias

  function build_package_version() {
    local output=$(sfdx force:package:version:create --package $package_name --installationkeybypass --wait 10 --json --targetdevhubusername $1)
    if [ ! $output ]; then exit 1; fi
    local subscriber_package_version_id=$(jq ".result.SubscriberPackageVersionId" -r <<< $output)
    echo "$subscriber_package_version_id" > SUBSCRIBER_PACKAGE_VERSION_ID.TXT
  }


  # Install a package version
  # Pass targetusername as argument -- assumes package ID is stored

  function install_package_version() {
    sfdx force:package:install --package "`cat SUBSCRIBER_PACKAGE_VERSION_ID.TXT`" --wait 10 --publishwait 10 --targetusername $1 --noprompt
  }


  # Promote package version
  # Only required in production
  # Pass in the username/alias of the org (probably PRODUCTION)

  function promote_package_version() {
    sfdx force:package:version:promote --package "`cat SUBSCRIBER_PACKAGE_VERSION_ID.TXT`" --targetdevhubusername $1 --noprompt
  }


  # Populate the URL artifact with HTML to redirect to an environment
  # NOTE: This is a tokenized URL and must be kept secret!
  # Pass targetusername as argument

  function populate_url_artifact() {
    if [ ! $1 ]; then exit 1; fi
    local output=$(sfdx force:org:open --targetusername $1 --urlonly --json)
    local url=$(jq -r ".result.url" <<< $output)
    environment_html="<script>window.onload=function(){window.location.href=\"$url\"}</script>"
    echo "To browse the scratch org, click 'Browse' under 'Job artifacts' and select 'ENVIRONMENT.html'"
  }


  # Create a scratch org
  # - Pass targetusername (the hub org alias) as argument
  # - Assumes there is a config/project-scratch-def.json file
  # - Sets $scratch_org_username
  # TODO: Remember scratch org username for the branch

  function create_scratch_org() {
    local output=$(sfdx force:org:create --targetdevhubusername $1 --setdefaultusername --definitionfile config/project-scratch-def.json --wait 10 --durationdays 1 --json)
    scratch_org_username="$(jq -r '.result.username' <<< $output)"
  }


  # Push to scratch org
  # TODO: Assumes username is available in SCRATCH_ORG_USERNAME.txt

  function push_to_scratch_org_and_test() {
    if [ ! $scratch_org_username ]; then exit 1; fi
    #sfdx force:org:display --targetusername "$scratch_org_username"
    sfdx force:source:push --targetusername $scratch_org_username
    #sfdx force:user:permset:assign --targetusername `cat SCRATCH_ORG_USERNAME.txt` --permsetname ______
    #sfdx force:data:tree:import --plan data/sample-data-plan.json
    #sfdx force:apex:test:run --targetusername $scratch_org_username --wait 10 --resultformat human --codecoverage --testlevel _________
  }


  # Delete a scratch org
  # Pass in the scratch_org_username

  function delete_scratch_org() {
    if [ ! $1 ]; then exit 1; fi
    sfdx force:data:record:delete --sobjecttype ScratchOrgInfo --targetusername HUB_ORG_ALIAS --where "SignupUsername='$1'"
  }


  # Checks if there are LWC Jest Test files in any of the package directories of sfdx-project.json
  # Function takes no arguments
  # Returns `true` or `false`

  function check_has_jest_tests() {
    local hasJestTests=false
    for pkgDir in $(jq -r '.packageDirectories[].path' < sfdx-project.json)
    do
      if [ -f $pkgDir ]; then
        local fileCnt=$(find $pkgDir -type f -path "**/__tests__/*.test.js" | wc -l);
        if [ $fileCnt -gt 0 ]; then
          hasJestTests=true
        fi
      fi
    done
    echo $hasJestTests
  }


  ## Runs `npm run test:unit` to execute LWC Jest tests.
  ## Function takes no arguments.
  ## Should be called after `setup_lwc`.
  ## Uses `check_has_jest_tests` to know if there are actually any tests to run.

  function test_lwc() {
    local hasJestTests=$(check_has_jest_tests)
    if [ $hasJestTests ]; then
      npm run test:unit
    else
      echo 'Skipping lwc tests, found no jest tests in any package directories'
    fi
  }


before_script:
  - *sfdx_helpers

